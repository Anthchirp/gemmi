#!/usr/bin/env cctbx.python

import shlex
import sys

from cctbx import sgtbx
try:
    from gemmi import sym
except ImportError:
    sym = None

syminfo_path = sys.argv[1]

def parse_syminfo(path):
    data = []
    cur = None
    with open(path) as f:
        for line in f:
            line = line.strip()
            if not line or line[0] == '#':
                continue
            if line == 'begin_spacegroup':
                assert cur is None, line
                cur = {'symops': [], 'cenops': []}
                continue
            assert cur is not None, line
            if line == 'end_spacegroup':
                for must_have in ['basisop', 'ccp4', 'number', 'hall', 'xhm']:
                    assert must_have in cur, must_have
                for must_have_list in ['symops', 'cenops']:
                    assert len(cur[must_have_list]) > 0
                verify_hall_symbol(cur)
                data.append(cur)
                cur = None
            elif line.startswith('number '):
                cur['number'] = int(line[6:])
            elif line.startswith('basisop '):
                cur['basisop'] = line[8:]
            elif line.startswith('symbol ccp4 '):
                cur['ccp4'] = int(line[12:])
                assert cur['ccp4'] == 0 or cur['ccp4'] % 1000 == cur['number']
            elif line.startswith('symbol Hall '):
                cur['hall'] = line[12:].strip(" '")
            elif line.startswith('symbol xHM '):
                cur['xhm'] = line[11:].strip(" '").replace(' :', ':')
            elif line.startswith('symbol old '):
                cur['old'] = shlex.split(line[11:])
            elif line.startswith('symop '):
                cur['symops'].append(line[6:])
            elif line.startswith('cenop '):
                cur['cenops'].append(line[6:])
    return data

def verify_hall_symbol(entry):
    if not sym:
        return
    hall_ops = sym.symops_from_hall(entry['hall'])
    assert len(hall_ops.sym_ops) == len(entry['symops'])
    assert len(hall_ops.cen_ops) == len(entry['cenops'])
    # centering vectors are exactly the same
    assert set(sym.Op().translated(tr) for tr in hall_ops.cen_ops) == \
           set(entry['cenops'])
    # symops differ in some cases but are the same modulo centering vectors
    given = set(sym.Op(s) * c for s in entry['symops'] for c in entry['cenops'])
    assert given == set(hall_ops), entry


syminfo_data = parse_syminfo(syminfo_path)
syminfo_dict = {}
for item in syminfo_data:
    # handle duplicates in syminfo.lib: pick the the one with ccp4 number
    if item['xhm'] not in syminfo_dict or item['ccp4'] != 0:
        syminfo_dict[item['xhm']] = item

print '  // This table was generated by tools/gen_sg_table.py.'
print '  // First 530 entries in the same order as in SgInfo, sgtbx and ITB.'
print '  // (including 3 dups in spacegroup 68)'
counter = 0
fmt = '  {%3d, %4d, %-12s, %s, %6s, %-17s}, // %3d'
def quot(s):
    return '"%s"' % s
for s in sgtbx.space_group_symbol_iterator():
    xhm = s.hermann_mauguin()
    ext = '  0'
    if s.extension() != '\0':
        xhm += ':%s' % s.extension()
        ext = "'%c'" % s.extension()
    syminfo_item = syminfo_dict.pop(xhm)
    assert syminfo_item['number'] == s.number()
    if sym:
        assert set(sym.symops_from_hall(s.hall())) == \
               set(sym.symops_from_hall(item['hall'])), xhm
    print fmt % (s.number(), syminfo_item['ccp4'], quot(s.hermann_mauguin()),
                 ext, quot(s.qualifier()), quot(s.hall()), counter)
    counter += 1
print '  // Then extra entries from syminfo.lib'
for item in syminfo_data:
    if item['xhm'] in syminfo_dict:  # i.e. it was not printed yet
        hm = item['xhm']
        ext = '  0'
        if ':' in hm:
            hm, ext = hm.split(':')
            ext = "'%c'" % ext
        #print fmt % (item['number'], item['ccp4'], quot(hm), ext, '""',
        #             quot(item['hall']), counter)
        counter += 1
